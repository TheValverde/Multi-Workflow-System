import { NextRequest, NextResponse } from "next/server";
import { getSupabaseServiceRoleClient } from "@/lib/supabase";
import {
  fetchEstimateDetail,
  upsertBusinessCase,
} from "@/lib/estimates";
import { logTimelineEntry } from "@/lib/timeline";

function composeBusinessCase(detail: Awaited<ReturnType<typeof fetchEstimateDetail>>) {
  if (!detail) {
    return "<p>No project context available.</p>";
  }

  // Use extracted content from artifacts if available
  const artifactsWithContent = detail.artifacts.filter(
    (a) => a.extract?.extraction_status === "ready" && a.extract.content_text,
  );
  const artifactsWithoutContent = detail.artifacts.filter(
    (a) => !a.extract || a.extract.extraction_status !== "ready",
  );

  let artifactItems = "";
  if (artifactsWithContent.length > 0) {
    artifactItems = artifactsWithContent
      .slice(0, 5)
      .map((artifact) => {
        const extract = artifact.extract!;
        // Use summary if available, otherwise clean and truncate content
        const preview = extract.summary || 
          cleanArtifactContent(extract.content_text || "")
            .substring(0, 200)
            .replace(/\n/g, " ")
            .trim();
        return `<li><strong>${escapeHtml(artifact.filename)}</strong> · ${formatRelativeDate(artifact.created_at)}<br><em>From ${escapeHtml(artifact.filename)}:</em> ${escapeHtml(preview)}${extract.content_text && extract.content_text.length > 200 ? "..." : ""}</li>`;
      })
      .join("");
  }

  if (artifactsWithoutContent.length > 0) {
    const fallbackItems = artifactsWithoutContent
      .slice(0, 5)
      .map(
        (artifact) =>
          `<li><strong>${escapeHtml(artifact.filename)}</strong> · ${formatRelativeDate(artifact.created_at)} (extraction ${artifact.extract?.extraction_status || "pending"})</li>`,
      )
      .join("");
    artifactItems += fallbackItems;
  }

  if (!artifactItems) {
    artifactItems = "<li>No supporting artifacts uploaded yet.</li>";
  }

  return [
    `<h3>Executive Summary</h3>`,
    `<p>Project <strong>${escapeHtml(detail.estimate.name)}</strong> led by <strong>${escapeHtml(detail.estimate.owner)}</strong> is currently tracking through the <em>${escapeHtml(detail.estimate.stage)}</em> stage.</p>`,
    `<h3>Goals &amp; Outcomes</h3>`,
    `<ul><li>Deliver a high-confidence proposal with clear ROI evidence.</li><li>Align stakeholders on scope, constraints, and success metrics.</li><li>Ensure approvals are auditable via the stage timeline.</li></ul>`,
    `<h3>Supporting Artifacts</h3>`,
    `<ul>${artifactItems}</ul>`,
    `<h3>Next Steps</h3>`,
    `<ol><li>Review this draft with delivery and finance stakeholders.</li><li>Capture final edits directly in the editor.</li><li>Approve to unlock the Requirements stage.</li></ol>`,
  ].join("");
}

function formatRelativeDate(value: string) {
  try {
    const date = new Date(value);
    return date.toLocaleDateString();
  } catch {
    return value;
  }
}

function escapeHtml(value: string) {
  return value
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}

/**
 * Clean artifact content by removing metadata, headers, and export info
 */
function cleanArtifactContent(content: string): string {
  // Remove common markdown metadata patterns
  let cleaned = content
    // Remove export metadata (e.g., "_Exported on...")
    .replace(/^_Exported on[^\n]*\n/gm, "")
    // Remove file path references at start
    .replace(/^#\s+.*\.md\s*$/gm, "")
    // Remove "from Cursor" type metadata
    .replace(/from Cursor[^\n]*/gi, "")
    // Remove horizontal rules used as separators
    .replace(/^---+\s*$/gm, "")
    // Remove excessive whitespace
    .replace(/\n{3,}/g, "\n\n")
    .trim();

  // Find the first meaningful content (skip headers/metadata)
  const lines = cleaned.split("\n");
  let startIndex = 0;
  
  // Skip lines that look like metadata
  for (let i = 0; i < Math.min(10, lines.length); i++) {
    const line = lines[i].trim();
    // Skip empty lines, export metadata, or very short header-only lines
    if (line && !line.match(/^(Exported|from|#\s*$)/i) && line.length > 10) {
      startIndex = i;
      break;
    }
  }
  
  return lines.slice(startIndex).join("\n").trim();
}

export async function POST(
  _request: NextRequest,
  context: { params: Promise<{ id: string }> },
) {
  const { id: estimateId } = await context.params;
  const supabase = getSupabaseServiceRoleClient();
  const detail = await fetchEstimateDetail(supabase, estimateId);
  if (!detail) {
    return NextResponse.json({ error: "Estimate not found" }, { status: 404 });
  }

  const generatedContent = composeBusinessCase(detail);

  await upsertBusinessCase(supabase, estimateId, {
    content: generatedContent,
    approved: false,
    approved_by: null,
  });

  await logTimelineEntry(
    supabase,
    estimateId,
    "Business Case",
    "Business Case generated by Copilot",
    "Copilot",
  );

  const updatedDetail = await fetchEstimateDetail(supabase, estimateId);
  return NextResponse.json(updatedDetail, { status: 200 });
}

